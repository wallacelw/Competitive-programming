\chapter{Data structures}

\section{Stack}

    An optimization for \textit{std::stack} is to use a \textit{std::vector} as the container, instead of \textit{std::deque} !

    \begin{lstlisting}[language=c++]
        stack<int, vector<int>> st;
    \end{lstlisting}

    A stack can be used to efficiently solve the maximum rectangle in a histogram problem:

    \kactlimport{max-rectangle-histogram.cpp}

    Also can be used to solve the maximum rectangle in a grid, with some blocked spots:

    \kactlimport{max-rectangle-grid.cpp}

\section{List}

    \textit{std::list} is a container that supports constant time insertion and removal of elements from anywhere in the container.

    Adding, removing and moving the elements within the list or across several lists does not invalidate the iterators or references.
    An iterator is invalidated only when the corresponding element is deleted.

    \textbf{Element Access: O(1)}

    \begin{itemize}
    \item \textit{list.back()}
    \item \textit{list.front()}
    \end{itemize}

    \textbf{Modifiers: O(1)}

    \begin{itemize}
    \item \textit{list.insert(itr, val)} 
    inserts val before itr and returns an itr to the inserted value

    \item \textit{list.erase(itr)} 
    erases the element referenced by itr and returns the itr for the next value (or .end())

    \item \textit{list.push\_back(val)}
    \item \textit{list.pop\_back(val)}
    \item \textit{list.push\_front(val)}
    \item \textit{list.pop\_back(val)}
    \end{itemize}
    
\section{Ordered Set}

    Policy Based Data Structures (PBDS) from gcc compiler

    Ordered Multiset can be created using ordered\_set\textless pll\textgreater {val, idx}

    \textbf{order\_of\_key()} can search for non-existent keys!
    
    \textbf{find\_by\_order()} requires existent key and return the 0-idx position of the given value.
    Therefore, it returns the numbers of elements that are smaller than the given value;

    \kactlimport{ordered-set.cpp}

    \subsection{Pyramid Array min-cost}

    You are given an array consisting of n integers. On each move, you can swap any two adjacent values.
    You want to transform the array into a pyramid array. This means that the final array has to be first increasing and then decreasing. 
    It is also allowed that the final array is only increasing or decreasing.
    What is the minimum number of moves needed?

    \kactlimport{pyramid-array.cpp}

\section{Interval Set}

    \kactlimport{interval-set.cpp}

\section{Disjoint Set Union}

    There are two optional improvements:

    \begin{itemize}
        \item Tree Balancing 
        \item Path Compression
    \end{itemize}
    If one improvement is used, 
    the time complexity will become $O(\log{N})$

    If both are used, $O(\alpha) \approx O(5)$

    \kactlimport{dsu.cpp}

\section{Trie}

    Also called a \textbf{digital tree} or \textbf{prefix tree}.
    
    \kactlimport{trie.cpp}

\section{Segment Trees}

    Each node of the segment tree represents the cumulative value of a range.

    \textbf{Observation:} For some problems, such as range distinct values query,
    considerer offiline approach, ordering the queries by L for example. 

    \subsection{Recursive SegTree}

        \kactlimport{seg-recursive-sum.cpp}

        \kactlimport{seg-recursive-minmax.cpp}

    \subsection{Inverted Segtree}

        Instead of keeping the prefix sum for all the children in each node, store only the delta encoding value.

        Therefore, to check a value in a certain position, iterate and sum all delta values from root to leaf.

        \kactlimport{seg-inverted.cpp}

    \subsection{PA Segtree}

        \kactlimport{seg-pa.cpp}

\section{Treap}

    \kactlimport{treap.cpp}